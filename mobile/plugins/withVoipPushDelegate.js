/**
 * Expo Config Plugin: withVoipPushDelegate (Swift Version for SDK 54+)
 *
 * This plugin adds PKPushRegistryDelegate implementation to AppDelegate.swift
 * for handling VoIP push notifications on iOS.
 *
 * Changes made:
 * 1. Creates/updates bridging header with RNVoipPushNotificationManager import
 * 2. Modifies AppDelegate.swift to conform to PKPushRegistryDelegate
 * 3. Adds delegate methods in Swift syntax
 * 4. Adds VoIP registration call in didFinishLaunchingWithOptions
 *
 * @see https://github.com/react-native-webrtc/react-native-voip-push-notification
 */

const {
  withAppDelegate,
  withInfoPlist,
  withDangerousMod,
  withXcodeProject,
} = require('@expo/config-plugins');
const fs = require('fs');
const path = require('path');

// Helper to get iOS project path
function getProjectName(config) {
  return config.modRequest.projectName || config.name.replace(/[^a-zA-Z0-9]/g, '');
}

// Step 1: Ensure Info.plist has VoIP background mode
function withVoipInfoPlist(config) {
  return withInfoPlist(config, (config) => {
    const bgModes = config.modResults.UIBackgroundModes || [];

    const requiredModes = ['voip', 'remote-notification', 'fetch'];
    for (const mode of requiredModes) {
      if (!bgModes.includes(mode)) {
        bgModes.push(mode);
      }
    }

    config.modResults.UIBackgroundModes = bgModes;
    return config;
  });
}

// Step 2: Create/Update Bridging Header
function withVoipBridgingHeader(config) {
  return withDangerousMod(config, [
    'ios',
    async (config) => {
      const projectRoot = config.modRequest.platformProjectRoot;
      const projectName = getProjectName(config);

      // Bridging header path
      const bridgingHeaderPath = path.join(
        projectRoot,
        projectName,
        `${projectName}-Bridging-Header.h`
      );

      // Content to add
      const voipImport = '#import "RNVoipPushNotificationManager.h"';
      const callkeepImport = '#import "RNCallKeep.h"';

      let headerContent = '';

      // Check if bridging header already exists
      if (fs.existsSync(bridgingHeaderPath)) {
        headerContent = fs.readFileSync(bridgingHeaderPath, 'utf8');
        if (!headerContent.includes(voipImport)) {
          headerContent += `\n${voipImport}\n`;
        }
        if (!headerContent.includes(callkeepImport)) {
          headerContent += `${callkeepImport}\n`;
        }
      } else {
        // Create new bridging header
        headerContent = `//
//  ${projectName}-Bridging-Header.h
//  ${projectName}
//
//  Auto-generated by withVoipPushDelegate config plugin
//

#import <React/RCTBridgeModule.h>
#import <React/RCTEventEmitter.h>
${voipImport}
${callkeepImport}
`;
      }

      fs.writeFileSync(bridgingHeaderPath, headerContent);
      console.log('[withVoipPushDelegate] Bridging header updated:', bridgingHeaderPath);

      return config;
    },
  ]);
}

// Step 3: Configure Xcode project to use bridging header
function withVoipXcodeProject(config) {
  return withXcodeProject(config, (config) => {
    const projectName = getProjectName(config);
    const bridgingHeaderPath = `${projectName}/${projectName}-Bridging-Header.h`;

    const xcodeProject = config.modResults;
    const configurations = xcodeProject.pbxXCBuildConfigurationSection();

    // Add bridging header to all configurations
    for (const key in configurations) {
      if (typeof configurations[key].buildSettings !== 'undefined') {
        const buildSettings = configurations[key].buildSettings;

        // Only set for targets that don't already have a bridging header
        if (!buildSettings['SWIFT_OBJC_BRIDGING_HEADER']) {
          buildSettings['SWIFT_OBJC_BRIDGING_HEADER'] = `"${bridgingHeaderPath}"`;
        }
      }
    }

    console.log('[withVoipPushDelegate] Xcode project configured with bridging header');
    return config;
  });
}

// Step 4: Modify AppDelegate.swift
function withVoipAppDelegate(config) {
  return withAppDelegate(config, (config) => {
    // Check if this is Swift (SDK 54+) or Objective-C
    const isSwift = config.modResults.language === 'swift';
    let contents = config.modResults.contents;

    if (isSwift) {
      contents = modifySwiftAppDelegate(contents);
    } else {
      contents = modifyObjCAppDelegate(contents);
    }

    config.modResults.contents = contents;
    return config;
  });
}

// Modify Swift AppDelegate (SDK 54+)
function modifySwiftAppDelegate(contents) {
  // 1. Add PushKit import if not present
  if (!contents.includes('import PushKit')) {
    contents = contents.replace(
      /import UIKit/,
      'import UIKit\nimport PushKit'
    );
  }

  // 2. Add VoIP registration in didFinishLaunchingWithOptions
  if (!contents.includes('RNVoipPushNotificationManager.voipRegistration')) {
    // Find the didFinishLaunchingWithOptions method and add registration after super call
    // Pattern for: return super.application(application, didFinishLaunchingWithOptions: launchOptions)
    const superCallPattern = /(return\s+super\.application\s*\(\s*application\s*,\s*didFinishLaunchingWithOptions\s*:\s*launchOptions\s*\))/;

    if (superCallPattern.test(contents)) {
      contents = contents.replace(
        superCallPattern,
        `// VoIP Push Registration - must be called early
    RNVoipPushNotificationManager.voipRegistration()

    $1`
      );
    } else {
      // Alternative: try to add after the opening of didFinishLaunchingWithOptions
      const didFinishPattern = /(func\s+application\s*\(\s*_\s+application:\s*UIApplication\s*,\s*didFinishLaunchingWithOptions\s+launchOptions:\s*\[UIApplication\.LaunchOptionsKey\s*:\s*Any\]\?\s*(?:=\s*nil\s*)?\)\s*->\s*Bool\s*\{)/;

      if (didFinishPattern.test(contents)) {
        contents = contents.replace(
          didFinishPattern,
          `$1
    // VoIP Push Registration - must be called early
    RNVoipPushNotificationManager.voipRegistration()
`
        );
      }
    }
  }

  // 3. Add PKPushRegistryDelegate as an extension at the end of the file
  // This is cleaner than modifying the class declaration
  if (!contents.includes('extension AppDelegate: PKPushRegistryDelegate')) {
    const delegateExtension = `

// MARK: - PKPushRegistryDelegate Extension
extension AppDelegate: PKPushRegistryDelegate {

  public func pushRegistry(_ registry: PKPushRegistry, didUpdate pushCredentials: PKPushCredentials, for type: PKPushType) {
    print("[Whisper] VoIP Push credentials updated for type: \\(type.rawValue)")
    RNVoipPushNotificationManager.didUpdatePushCredentials(pushCredentials, forType: type.rawValue)
  }

  public func pushRegistry(_ registry: PKPushRegistry, didReceiveIncomingPushWith payload: PKPushPayload, for type: PKPushType, completion: @escaping () -> Void) {
    print("[Whisper] VoIP Push received with payload: \\(payload.dictionaryPayload)")

    let uuidString = UUID().uuidString.lowercased()
    let callerName = payload.dictionaryPayload["fromWhisperId"] as? String ?? "Incoming Call"
    let hasVideo = payload.dictionaryPayload["isVideo"] as? Bool ?? false

    // Report to CallKit via RNCallKeep (triggers native call UI)
    RNCallKeep.reportNewIncomingCall(
      uuidString,
      handle: callerName,
      handleType: "generic",
      hasVideo: hasVideo,
      localizedCallerName: callerName,
      fromPushKit: true,
      payload: payload.dictionaryPayload,
      withCompletionHandler: completion
    )

    // Forward to VoIP manager for JS event
    RNVoipPushNotificationManager.didReceiveIncomingPush(withPayload: payload, forType: type.rawValue)
  }

  public func pushRegistry(_ registry: PKPushRegistry, didInvalidatePushTokenFor type: PKPushType) {
    print("[Whisper] VoIP Push token invalidated for type: \\(type.rawValue)")
  }
}
`;

    // Append extension to the end of the file
    contents = contents + delegateExtension;
  }

  return contents;
}

// Modify Objective-C AppDelegate (fallback for older SDK)
function modifyObjCAppDelegate(contents) {
  // 1. Add imports
  if (!contents.includes('#import <PushKit/PushKit.h>')) {
    contents = contents.replace(
      /#import "AppDelegate.h"/,
      `#import "AppDelegate.h"
#import <PushKit/PushKit.h>
#import "RNVoipPushNotificationManager.h"`
    );
  }

  // 2. Add PKPushRegistryDelegate to interface
  if (!contents.includes('<PKPushRegistryDelegate>')) {
    contents = contents.replace(
      /@interface AppDelegate : EXAppDelegateWrapper/,
      '@interface AppDelegate : EXAppDelegateWrapper <PKPushRegistryDelegate>'
    );
  }

  // 3. Add delegate methods
  if (!contents.includes('didUpdatePushCredentials')) {
    const delegateMethods = `

#pragma mark - PKPushRegistryDelegate

- (void)pushRegistry:(PKPushRegistry *)registry didUpdatePushCredentials:(PKPushCredentials *)credentials forType:(PKPushType)type {
  NSLog(@"[Whisper] VoIP Push credentials updated for type: %@", type);
  [RNVoipPushNotificationManager didUpdatePushCredentials:credentials forType:(NSString *)type];
}

- (void)pushRegistry:(PKPushRegistry *)registry didReceiveIncomingPushWithPayload:(PKPushPayload *)payload forType:(PKPushType)type withCompletionHandler:(void (^)(void))completion {
  NSLog(@"[Whisper] VoIP Push received with payload: %@", payload.dictionaryPayload);
  NSString *uuid = payload.dictionaryPayload[@"callId"] ?: [[NSUUID UUID] UUIDString];
  [RNVoipPushNotificationManager addCompletionHandler:uuid completionHandler:completion];
  [RNVoipPushNotificationManager didReceiveIncomingPushWithPayload:payload forType:(NSString *)type];
}

- (void)pushRegistry:(PKPushRegistry *)registry didInvalidatePushTokenForType:(PKPushType)type {
  NSLog(@"[Whisper] VoIP Push token invalidated for type: %@", type);
}
`;

    const lastEndIndex = contents.lastIndexOf('@end');
    if (lastEndIndex !== -1) {
      contents = contents.slice(0, lastEndIndex) + delegateMethods + '\n' + contents.slice(lastEndIndex);
    }
  }

  // 4. Add VoIP registration
  if (!contents.includes('voipRegistration')) {
    contents = contents.replace(
      /return \[super application:application didFinishLaunchingWithOptions:launchOptions\];/,
      `// VoIP Push Registration
  [RNVoipPushNotificationManager voipRegistration];

  return [super application:application didFinishLaunchingWithOptions:launchOptions];`
    );
  }

  return contents;
}

// Main plugin - compose all modifications
function withVoipPushDelegate(config) {
  config = withVoipInfoPlist(config);
  config = withVoipBridgingHeader(config);
  config = withVoipXcodeProject(config);
  config = withVoipAppDelegate(config);

  return config;
}

module.exports = withVoipPushDelegate;
